<!DOCTYPE html>
<html lang="id">
<head>
    <meta charset="UTF-8">
    <title>1-Bit Glitch Protocol | V35_FINAL_CUT</title>
    <link href="https://fonts.googleapis.com/css2?family=VT323&display=swap" rel="stylesheet">
    <style>
        body { margin: 0; overflow: hidden; background: #050505; display: flex; justify-content: center; align-items: center; height: 100vh; font-family: 'VT323', monospace; color: #fff; }
        
        #game-container { position: relative; width: 800px; height: 600px; box-shadow: 0 0 50px rgba(0, 255, 0, 0.1); }
        canvas { width: 100%; height: 100%; background: #000; image-rendering: pixelated; filter: contrast(1.2) brightness(1.1); }
        
        /* UI LAYERS */
        #boot, #upgrade-ui, #victory-ui, #tutorial-ui { 
            position: absolute; top: 0; left: 0; background: rgba(0, 5, 0, 0.95); width: 100%; height: 100%; 
            display: flex; flex-direction: column; justify-content: center; align-items: center; z-index: 20; 
            border: 2px solid #0f0; box-sizing: border-box; box-shadow: inset 0 0 100px rgba(0, 20, 0, 0.8);
        }
        #upgrade-ui, #victory-ui, #tutorial-ui { display: none; }
        
        /* TUTORIAL STYLES */
        .key-row { width: 60%; display: flex; justify-content: space-between; margin: 10px 0; border-bottom: 1px dashed #333; padding-bottom: 5px; }
        .key { color: #0ff; font-size: 24px; font-weight: bold; text-shadow: 0 0 10px #0ff; }
        .desc { color: #fff; font-size: 20px; opacity: 0.8; }

        /* UPGRADE CARDS */
        #options-container { display: flex; gap: 20px; flex-wrap: wrap; justify-content: center; width: 100%; }
        .option { 
            border: 1px solid #0f0; padding: 15px; width: 220px; height: 320px; cursor: pointer; transition: 0.2s; 
            background: rgba(0, 20, 0, 0.85); display: flex; flex-direction: column; justify-content: space-between; 
            position: relative; overflow: hidden; box-shadow: 0 0 10px rgba(0, 255, 0, 0.1);
        }
        .option:hover { background: #001a00; border-color: #fff; box-shadow: 0 0 30px #0f0; transform: scale(1.02); }
        .option h3 { margin: 0 0 5px 0; font-size: 24px; border-bottom: 1px dashed #0f0; padding-bottom: 5px; }
        .option .type-tag { position: absolute; top:0; right:0; background: #0f0; color:#000; padding:2px 6px; font-size:14px; font-weight:bold;}
        .stat-bar { height: 6px; background: #111; margin-top: 4px; margin-bottom: 8px; border: 1px solid #333; }
        .stat-fill { height: 100%; display: block; box-shadow: 0 0 5px currentColor; }
        
        .scanline { position: absolute; top: 0; left: 0; width: 100%; height: 100%; pointer-events: none; z-index: 15; background: linear-gradient(to bottom, rgba(255,255,255,0), rgba(255,255,255,0) 50%, rgba(0,0,0,0.2) 50%, rgba(0,0,0,0.2)); background-size: 100% 4px; animation: scanline 10s linear infinite; opacity: 0.6; }
        .vignette { position: absolute; top: 0; left: 0; width: 100%; height: 100%; pointer-events: none; z-index: 16; background: radial-gradient(circle, rgba(0,0,0,0) 60%, rgba(0,0,0,0.8) 100%); }
        
        .blink { animation: blinker 0.2s steps(2, start) infinite; color: #0f0; }
        @keyframes blinker { 50% { opacity: 0; } }
        @keyframes scanline { 0% { background-position: 0 0; } 100% { background-position: 0 100%; } }
        h1 { font-size: 60px; margin: 0; } h2 { font-size: 40px; margin: 0; } div { font-size: 18px; }
    </style>
</head>
<body>
    <div id="game-container">
        <div class="scanline"></div>
        <div class="vignette"></div>

        <div id="boot">
            <h1 style="text-shadow: 4px 0 #f00, -4px 0 #00f;">[ ARSENAL_V35 ]</h1>
            <p class="blink" style="margin-top: 20px; font-size: 24px;">>> PRESS_ANY_KEY_TO_INITIALIZE <<</p>
            <div style="font-size: 14px; opacity: 0.7; margin-top: 50px; text-align: center; color: #888;">
                UPDATE: 4_STAGE_STRUCTURE_LOCKED<br>
                UPDATE: ENEMY_SPAWN_RATE_UNLOCKED<br>
                SYSTEM: READY
            </div>
            <div style="margin-top: 80px; font-size: 16px; color: #0f0; border-top: 1px solid #0f0; padding-top: 10px;">
                DEV_CREDIT: ROFI ARASYI
            </div>
        </div>

        <div id="tutorial-ui">
            <h2 style="color: #0f0; margin-bottom: 30px; text-decoration: underline;">>> SYSTEM_MANUAL <<</h2>
            <div class="key-row"><span class="key">[ W, A, S, D ]</span><span class="desc">DIRECTIONAL THRUST</span></div>
            <div class="key-row"><span class="key">[ SPACE ]</span><span class="desc">AUTO-FIRE SEQUENCE</span></div>
            <div class="key-row"><span class="key">[ SHIFT ]</span><span class="desc">PRECISION MODE (SLOW)</span></div>
            <div class="key-row"><span class="key">[ Q ]</span><span class="desc">EMERGENCY WIPE (-SCORE)</span></div>
            <div style="margin-top: 50px; text-align: center; color: #888; font-size: 14px;">TIP: MAXIMIZE 4 WEAPONS BEFORE THE FINAL BOSS.</div>
            <p class="blink" style="margin-top: 30px; font-size: 24px; cursor: pointer; color: #fff;">>> CLICK_TO_ENGAGE <<</p>
        </div>

        <div id="upgrade-ui">
            <h2 style="color: #0f0; text-shadow: 0 0 20px #0f0; margin-bottom: 30px;">>> PREPARE_FOR_BOSS <<</h2>
            <div id="options-container"></div>
        </div>

        <div id="victory-ui">
            <h1 style="color: #0ff; text-shadow: 0 0 30px #0ff; letter-spacing: 5px;">MISSION ACCOMPLISHED</h1>
            <p style="margin-top: 20px; font-size: 24px; color: #fff;">CORE SYSTEM SECURED</p>
            <div style="margin-top: 30px; font-size: 20px; color: #0f0;">CREDIT: ROFI ARASYI</div>
            <div style="margin-top: 50px; text-align: center;">
                <p id="final-score" style="color: #0f0;"></p>
                <p class="blink" style="margin-top: 30px; font-size: 14px; cursor: pointer;" onclick="location.reload()">>> REBOOT <<</p>
            </div>
        </div>

        <canvas id="gameCanvas"></canvas>
    </div>

<script>
    const boot = document.getElementById('boot');
    const tutorialUI = document.getElementById('tutorial-ui');
    const upgradeUI = document.getElementById('upgrade-ui');
    const victoryUI = document.getElementById('victory-ui');
    const optionsContainer = document.getElementById('options-container');

    boot.onclick = () => { boot.style.display = 'none'; tutorialUI.style.display = 'flex'; };
    tutorialUI.onclick = () => { tutorialUI.style.display = 'none'; initGame(); };

    function initGame() {
        const C = { w: 800, h: 600, uiWidth: 220 };
        const canvas = document.getElementById('gameCanvas');
        const ctx = canvas.getContext('2d');
        canvas.width = C.w; canvas.height = C.h;

        // --- AUDIO ENGINE ---
        const AC = new (window.AudioContext || window.webkitAudioContext)();
        const masterGain = AC.createGain(); masterGain.connect(AC.destination); masterGain.gain.value = 0.3;
        const bufferSize = AC.sampleRate * 2; const noiseBuffer = AC.createBuffer(1, bufferSize, AC.sampleRate);
        const output = noiseBuffer.getChannelData(0); for (let i = 0; i < bufferSize; i++) output[i] = Math.random() * 2 - 1;

        let musicInterval = null;
        let currentTrack = 'NONE';

        function playSfx(type, pitch = 1, vol = 1) {
            if (AC.state === 'suspended') AC.resume();
            const gain = AC.createGain(); gain.connect(masterGain);
            if (type === 'shoot') {
                const osc = AC.createOscillator(); osc.type = 'sawtooth';
                osc.frequency.setValueAtTime(800 * pitch, AC.currentTime); osc.frequency.exponentialRampToValueAtTime(100, AC.currentTime + 0.15);
                gain.gain.setValueAtTime(0.1 * vol, AC.currentTime); gain.gain.exponentialRampToValueAtTime(0.01, AC.currentTime + 0.15);
                osc.connect(gain); osc.start(); osc.stop(AC.currentTime + 0.15);
            } else if (type === 'explode') {
                const noise = AC.createBufferSource(); noise.buffer = noiseBuffer;
                const filter = AC.createBiquadFilter(); filter.type = 'lowpass'; filter.frequency.value = 1000;
                noise.connect(filter); filter.connect(gain);
                gain.gain.setValueAtTime(0.3 * vol, AC.currentTime); gain.gain.exponentialRampToValueAtTime(0.01, AC.currentTime + 0.4);
                noise.start(); noise.stop(AC.currentTime + 0.4);
            } else if (type === 'hit') {
                const osc = AC.createOscillator(); osc.type = 'square';
                osc.frequency.setValueAtTime(150, AC.currentTime); osc.frequency.linearRampToValueAtTime(50, AC.currentTime + 0.1);
                gain.gain.setValueAtTime(0.2 * vol, AC.currentTime); gain.gain.linearRampToValueAtTime(0, AC.currentTime + 0.1);
                osc.connect(gain); osc.start(); osc.stop(AC.currentTime + 0.1);
            } else if (type === 'phase_shift') { 
                const osc = AC.createOscillator(); osc.type = 'sawtooth';
                osc.frequency.setValueAtTime(100, AC.currentTime); osc.frequency.linearRampToValueAtTime(800, AC.currentTime + 0.5);
                gain.gain.setValueAtTime(0.5, AC.currentTime); gain.gain.linearRampToValueAtTime(0, AC.currentTime + 0.5);
                osc.connect(gain); osc.start(); osc.stop(AC.currentTime + 0.5);
            } else if (type === 'powerup') {
                const osc = AC.createOscillator(); osc.type = 'sine';
                osc.frequency.setValueAtTime(400, AC.currentTime); osc.frequency.linearRampToValueAtTime(1200, AC.currentTime + 0.3);
                gain.gain.setValueAtTime(0.2 * vol, AC.currentTime); gain.gain.linearRampToValueAtTime(0, AC.currentTime + 0.3);
                osc.connect(gain); osc.start(); osc.stop(AC.currentTime + 0.3);
            } else if (type === 'win') {
                const osc = AC.createOscillator(); osc.type = 'triangle';
                osc.frequency.setValueAtTime(220, AC.currentTime); osc.frequency.linearRampToValueAtTime(880, AC.currentTime + 1.0);
                gain.gain.setValueAtTime(0.3, AC.currentTime); gain.gain.linearRampToValueAtTime(0, AC.currentTime + 2.0);
                osc.connect(gain); osc.start(); osc.stop(AC.currentTime + 2.0);
            }
        }
        playSfx('powerup');

        // --- DYNAMIC MUSIC SYSTEM ---
        function playMusic(trackType, bossId = 0, phase = 1) {
            if (currentTrack === trackType && trackType === 'AMBIENT') return; 
            if (musicInterval) clearInterval(musicInterval);
            currentTrack = trackType;

            let beat = 0;
            let tempo = 200; 
            let baseFreq = 100;
            let waveType = 'sawtooth';

            if (trackType === 'AMBIENT') {
                tempo = 400;
                musicInterval = setInterval(() => {
                    const t = AC.currentTime;
                    const osc = AC.createOscillator(); osc.type = 'sine';
                    const g = AC.createGain(); osc.connect(g); g.connect(masterGain);
                    osc.frequency.value = 60; 
                    g.gain.setValueAtTime(0.1, t); g.gain.exponentialRampToValueAtTime(0.001, t + 0.5);
                    osc.start(t); osc.stop(t + 0.5);
                    if (Math.random() > 0.5) {
                        const osc2 = AC.createOscillator(); osc2.type = 'square';
                        const g2 = AC.createGain(); osc2.connect(g2); g2.connect(masterGain);
                        osc2.frequency.value = 800 + Math.random() * 400;
                        g2.gain.setValueAtTime(0.02, t); g2.gain.exponentialRampToValueAtTime(0.001, t + 0.1);
                        osc2.start(t); osc2.stop(t + 0.1);
                    }
                }, tempo);
            } 
            else if (trackType === 'BOSS') {
                if (bossId === 0) { baseFreq = 120; waveType = 'square'; tempo = 180; } 
                else if (bossId === 1) { baseFreq = 150; waveType = 'sawtooth'; tempo = 160; } 
                else if (bossId === 2) { baseFreq = 100; waveType = 'triangle'; tempo = 150; } 
                else if (bossId === 3) { baseFreq = 80; waveType = 'sawtooth'; tempo = 110; } // Final Boss Fast

                if (phase === 2) { tempo *= 0.7; baseFreq *= 1.2; }

                musicInterval = setInterval(() => {
                    const t = AC.currentTime;
                    const osc = AC.createOscillator(); osc.type = waveType;
                    const g = AC.createGain(); osc.connect(g); g.connect(masterGain);
                    let freq = baseFreq;
                    if (beat % 2 === 0) freq *= 1.5; 
                    if (bossId === 1 && Math.random()>0.5) freq = Math.random()*500; 

                    osc.frequency.setValueAtTime(freq, t);
                    osc.frequency.exponentialRampToValueAtTime(0.01, t + 0.1);
                    g.gain.setValueAtTime(0.2, t);
                    g.gain.exponentialRampToValueAtTime(0.01, t + 0.1);
                    osc.start(t); osc.stop(t + 0.1);

                    if (beat % 2 !== 0 || (phase === 2 && beat % 1 === 0)) { 
                        const noise = AC.createBufferSource(); noise.buffer = noiseBuffer;
                        const ng = AC.createGain(); noise.connect(ng); ng.connect(masterGain);
                        ng.gain.setValueAtTime(0.05, t); ng.gain.exponentialRampToValueAtTime(0.001, t + 0.05);
                        noise.start(t); noise.stop(t + 0.05);
                    }
                    beat++;
                }, tempo);
            }
        }

        playMusic('AMBIENT');

        // --- GAME DATA ---
        const WEAPON_TYPES = [
            { id: 'standard', name: "CORE_BOLT", desc: "Standard energy.", ult: "TRIPLE STREAM", dmg: 10, color: "#fff", rate: 8 },
            { id: 'spread', name: "FAN_LOGIC", desc: "Area denial.", ult: "5-WAY BURST", dmg: 7, color: "#0ff", rate: 7 },
            { id: 'laser', name: "VOID_PIERCER", desc: "Penetration.", ult: "HYPER BEAM", dmg: 5, color: "#f0f", rate: 9 },
            { id: 'wave', name: "SINE_ERROR", desc: "Erratic path.", ult: "DOUBLE HELIX", dmg: 18, color: "#ff0", rate: 5 },
            { id: 'heavy', name: "NULL_POINTER", desc: "Heavy impact.", ult: "EXPLOSIVE", dmg: 60, color: "#f00", rate: 2 },
            { id: 'glitch', name: "BIT_CRUSHER", desc: "Damage over time.", ult: "SCREEN CORRUPTION", dmg: 35, color: "#0f0", rate: 4 },
            { id: 'rapid', name: "OVERCLOCK", desc: "Fast fire.", ult: "MINIGUN", dmg: 4, color: "#fff", rate: 10 },
            { id: 'orbit', name: "SENTINEL", desc: "Defense.", ult: "DUAL SHIELD", dmg: 15, color: "#fff", rate: 0 },
            { id: 'nova', name: "PLASMA_NOVA", desc: "Slow massive projectile.", ult: "SUPERNOVA", dmg: 80, color: "#FF4500", rate: 3 },
            { id: 'rail', name: "RAIL_CANNON", desc: "Instant velocity.", ult: "DUAL RAIL", dmg: 45, color: "#00BFFF", rate: 6 }
        ];

        // 4 Bosses Only (Merged Final)
        const BOSS_DATA = [
            { name: "ROOT_ACCESSOR", title: "GATEKEEPER", color: "#0ff", shape: "cube" },
            { name: "MEMORY_LEAK", title: "UNSTABLE", color: "#f0f", shape: "glitch" },
            { name: "LOGIC_BOMB", title: "CALCULATED", color: "#f00", shape: "pyramid" },
            { name: "KERNEL_PANIC", title: "THE END", color: "#fff", shape: "void" }
        ];

        const ENEMY_TYPES = [
            { type: 'grunt', hp: 15, s: 3, color: '#fff', score: 10 },
            { type: 'rusher', hp: 10, s: 6, color: '#f0f', score: 20 },
            { type: 'tank', hp: 100, s: 1.5, color: '#0ff', score: 50 },
            { type: 'sniper', hp: 20, s: 2, color: '#FFD700', score: 40 }, 
            { type: 'swarmer', hp: 5, s: 8, color: '#FF4500', score: 15 } 
        ];

        let score = 0, exp = 0, nextLevelExp = 800, frameCount = 0, health = 100, gameState = 'PLAY';
        let level = 1; let upgradesInStage = 0; 
        let shake = 0, damageFlash = 0;
        let bullets = [], enemyBullets = [], enemies = [], particles = [], drops = [], logs = ["> SYSTEM_START"];
        let boss = null;
        let p_weapons = [{ ...WEAPON_TYPES[0], level: 1 }]; 
        let gridOffset = 0;

        const keys = {};
        window.onkeydown = e => { keys[e.key.toLowerCase()] = true; if(e.key === " ") e.preventDefault(); if(e.key.toLowerCase() === 'q') manualBomb(); };
        window.onkeyup = e => keys[e.key.toLowerCase()] = false;

        function addLog(msg) { logs.push(`> ${msg}`); if (logs.length > 7) logs.shift(); }

        function triggerWipe(isManual = false) {
            if (isManual && score < 2000) { addLog("BOMB_ERROR: NEED_DATA"); return; }
            if (isManual) score -= 2000;
            enemies.forEach(e => createParticles(e.x+15, e.y+15, 20, "#fff", 2));
            enemies = []; enemyBullets = []; shake = 40; damageFlash = 15;
            addLog("CRITICAL_WIPE: SUCCESS"); playSfx('explode', 0.5, 0.8);
        }
        function manualBomb() { triggerWipe(true); }

        function createParticles(x, y, count = 8, color = "#fff", speedMod = 1) {
            for(let i=0; i<count; i++) {
                particles.push({ x, y, vx: (Math.random()-0.5)*10*speedMod, vy: (Math.random()-0.5)*10*speedMod, life: 1.0, decay: 0.03 + Math.random()*0.05, color, size: Math.random()*5 + 2 });
            }
        }

        function showUpgradeMenu() {
            gameState = 'UPGRADE'; upgradeUI.style.display = 'flex'; optionsContainer.innerHTML = '';
            let pool = [];
            p_weapons.forEach(pw => { if (pw.level < 3) pool.push({ ...pw, type: 'UPGRADE' }); });
            if (p_weapons.length < 4) {
                let newWeapons = WEAPON_TYPES.filter(wt => !p_weapons.some(pw => pw.id === wt.id));
                newWeapons.forEach(nw => { pool.push({ ...nw, type: 'NEW', level: 0 }); });
            }
            if (pool.length === 0) createHealOption();
            else {
                const shuffled = pool.sort(() => 0.5 - Math.random()).slice(0, 3);
                while(shuffled.length < 3) shuffled.push({ id: 'heal', name: "SYS_REPAIR", desc: "Restore 50% Integrity", dmg: 0, color: "#0f0", rate: 0, type: 'HEAL' });
                shuffled.forEach(w => createOptionCard(w));
            }
        }

        function createHealOption() { createOptionCard({ id: 'heal', name: "FULL_REPAIR", desc: "Restore 100% Integrity", dmg: 0, color: "#0f0", rate: 0, type: 'HEAL_FULL' }); }

        function createOptionCard(w) {
            const div = document.createElement('div'); div.className = 'option'; div.style.borderColor = w.color;
            let label = w.type; let titleColor = w.color; let desc = w.desc; let nextLvl = w.level ? w.level + 1 : 1;
            if (w.type === 'UPGRADE') { label = `UPGRADE > LVL ${nextLvl}`; if (nextLvl === 3) { label = "ULTIMATE"; titleColor = "#FFD700"; desc = ">> " + w.ult; } } 
            else if (w.type === 'NEW') label = "NEW MODULE";
            
            div.innerHTML = `
                <div class="type-tag" style="background:${titleColor}">${label}</div>
                <div style="margin-top:20px;"><h3 style="color:${titleColor}">${w.name}</h3><div style="font-size:16px; opacity:0.8; height:40px; line-height:1.2;">${desc}</div></div>
                <div style="text-align:right; font-size:14px; color:${titleColor}"><< INSTALL >></div>`;
            
            div.onclick = () => {
                playSfx('powerup', 1.5, 0.5);
                if (w.type.includes('HEAL')) { health = 100; addLog("SYSTEM_RESTORED"); } 
                else if (w.type === 'UPGRADE') { let target = p_weapons.find(pw => pw.id === w.id); if (target) { target.level++; addLog(`${target.name} UPGRADED`); } } 
                else if (w.type === 'NEW') { p_weapons.push({ ...w, level: 1 }); addLog(`MODULE INSTALLED`); }
                
                upgradesInStage++;
                if (upgradesInStage >= 3) {
                    boss = new Boss(level - 1);
                    playMusic('BOSS', boss.id, 1); 
                    addLog("WARNING: BOSS DETECTED");
                }

                upgradeUI.style.display = 'none'; gameState = 'PLAY';
            };
            optionsContainer.appendChild(div);
        }

        function triggerVictory() {
            gameState = 'VICTORY'; boss = null; enemies = []; enemyBullets = []; bullets = [];
            playMusic('AMBIENT');
            victoryUI.style.display = 'flex'; document.getElementById('final-score').innerText = `FINAL SCORE: ${score} | EXP: ${exp}`; playSfx('win');
        }

        class Boss {
            constructor(lvlIdx) {
                this.id = lvlIdx;
                this.data = BOSS_DATA[lvlIdx];
                this.size = 140;
                this.x = (C.w - C.uiWidth)/2 - this.size/2; this.y = -200;
                
                this.hp = 18000 + (lvlIdx * 8000); 
                
                this.maxHp = this.hp; 
                this.t = 0;
                this.phase = 1; 
                this.shifted = false; 
                this.phaseTimer = 0; 
            }
            
            update() {
                if (this.y < 80) this.y += 1;
                this.t += 0.03; 
                this.phaseTimer++;

                if (!this.shifted && this.hp < this.maxHp * 0.5) {
                    this.shifted = true;
                    this.phase = 2;
                    createParticles(this.x + this.size/2, this.y + this.size/2, 50, this.data.color, 4);
                    shake = 50; 
                    enemyBullets = []; 
                    playSfx('phase_shift');
                    playMusic('BOSS', this.id, 2); 
                    addLog(`BOSS PHASE 2: ${this.data.title}_OVERDRIVE`);
                }

                const cx = this.x + this.size/2, cy = this.y + this.size/2;

                if (this.phase === 1) {
                    this.x += Math.sin(this.t) * 2;
                    if (frameCount % 50 === 0) { // Slightly faster attack rate for base
                        playSfx('shoot', 0.4, 0.4);
                        let count = 10; // More bullets
                        for(let i=0; i<count; i++) {
                            let rad = (Math.PI*2/count)*i + this.t;
                            enemyBullets.push({x:cx, y:cy, vx:Math.cos(rad)*5, vy:Math.sin(rad)*5, sz:10});
                        }
                    }
                }
                else {
                    // PHASE 2 AGGRESSIVE PATTERNS
                    if (this.id === 0) { // CUBE
                        if (frameCount % 8 === 0) { // RAPID SPIN
                            playSfx('shoot', 0.5, 0.3);
                            let rad1 = this.t * 6; let rad2 = -this.t * 6;
                            enemyBullets.push({x:cx, y:cy, vx:Math.cos(rad1)*7, vy:Math.sin(rad1)*7, sz:8});
                            enemyBullets.push({x:cx, y:cy, vx:Math.cos(rad2)*7, vy:Math.sin(rad2)*7, sz:8});
                        }
                    }
                    else if (this.id === 1) { // GLITCH
                        if (this.phaseTimer % 120 === 0) { // Faster Teleport (2s)
                            this.x = Math.random() * (C.w - C.uiWidth - 200) + 50;
                            this.y = Math.random() * 200 + 50;
                            createParticles(this.x+70, this.y+70, 20, "#fff");
                            for(let i=0; i<12; i++) enemyBullets.push({x:this.x+70, y:this.y+70, vx:(Math.random()-0.5)*18, vy:(Math.random()-0.5)*18, sz:8});
                        }
                        this.x += (Math.random()-0.5) * 4; 
                    }
                    else if (this.id === 2) { // PYRAMID
                        this.size = 220; this.x = (C.w - C.uiWidth)/2 - this.size/2; 
                        if (frameCount % 60 === 0) { // Faster Lasers
                            enemyBullets.push({x:0, y:cy, vx:15, vy:0, sz:40, laser:true}); 
                            enemyBullets.push({x:C.w, y:cy, vx:-15, vy:0, sz:40, laser:true}); 
                            enemyBullets.push({x:cx, y:0, vx:0, vy:15, sz:40, laser:true}); 
                            // Diagonal
                            enemyBullets.push({x:0, y:0, vx:10, vy:10, sz:20, laser:true});
                            enemyBullets.push({x:C.w, y:0, vx:-10, vy:10, sz:20, laser:true});
                        }
                    }
                    else if (this.id === 3) { // VOID (FINAL)
                        // Super Suction
                        let dx = cx - player.x; let dy = cy - player.y; let dist = Math.sqrt(dx*dx + dy*dy);
                        player.x += (dx/dist) * 3.5; player.y += (dy/dist) * 3.5;
                        
                        if (frameCount % 20 === 0) { // Bullet Hell while sucking
                             for(let i=0; i<5; i++) {
                                let rad = Math.random() * Math.PI * 2;
                                enemyBullets.push({x:cx, y:cy, vx:Math.cos(rad)*9, vy:Math.sin(rad)*9, sz:8});
                             }
                        }
                    }
                }
            }

            draw() {
                ctx.save(); ctx.translate(this.x + this.size/2, this.y + this.size/2);
                
                if (this.phase === 2) {
                    ctx.shadowBlur = 50; ctx.shadowColor = "#f00"; ctx.translate((Math.random()-0.5)*5, (Math.random()-0.5)*5); 
                } else {
                    ctx.shadowBlur = 30; ctx.shadowColor = this.data.color; 
                }
                
                ctx.strokeStyle = this.phase === 2 ? "#fff" : this.data.color; ctx.lineWidth = 4;
                ctx.beginPath();
                
                if (this.data.shape === 'cube') { ctx.rotate(this.t * (this.phase)); ctx.strokeRect(-this.size/3, -this.size/3, this.size/1.5, this.size/1.5); } 
                else if (this.data.shape === 'glitch') { for(let i=0; i<6; i++) ctx.lineTo((Math.random()-0.5)*this.size, (Math.random()-0.5)*this.size); ctx.closePath(); ctx.stroke(); }
                else if (this.data.shape === 'final' || this.data.shape === 'void') { ctx.rotate(this.t); ctx.strokeRect(-60, -60, 120, 120); ctx.rotate(-this.t*2); ctx.strokeRect(-40, -40, 80, 80); }
                else { ctx.arc(0, 0, this.size/3, 0, Math.PI*2); ctx.stroke(); }
                
                ctx.restore();
                
                const barW = 400; const barX = (C.w - C.uiWidth) / 2 - barW / 2;
                ctx.fillStyle = "#200"; ctx.fillRect(barX, 30, barW, 10);
                ctx.fillStyle = this.phase === 2 ? "#f00" : this.data.color; 
                ctx.fillRect(barX, 30, (Math.max(0, this.hp) / this.maxHp) * barW, 10);
                ctx.strokeStyle = "#fff"; ctx.strokeRect(barX, 30, barW, 10);
                ctx.font = "18px VT323"; ctx.fillStyle = "#fff"; ctx.fillText(`WARNING: ${this.data.name} ${this.phase===2 ? '[OVERDRIVE]' : ''}`, barX, 25);
            }
        }

        class Player {
            constructor() { this.x = (C.w-C.uiWidth)/2; this.y = C.h-100; this.size = 24; }
            update() {
                let s = keys['shift'] ? 3.5 : 7;
                if (keys['w'] || keys['arrowup']) this.y -= s; if (keys['s'] || keys['arrowdown']) this.y += s;
                if (keys['a'] || keys['arrowleft']) this.x -= s; if (keys['d'] || keys['arrowright']) this.x += s;
                this.x = Math.max(0, Math.min(C.w - C.uiWidth - this.size, this.x)); this.y = Math.max(0, Math.min(C.h - this.size, this.y));
                if (keys[' '] && frameCount % 8 === 0) this.fire();
            }
            fire() {
                p_weapons.forEach((w) => {
                    const ox = this.x + this.size/2, oy = this.y;
                    let dmg = w.dmg * (1 + (w.level * 0.5)); let col = w.level === 3 ? '#FFD700' : w.color; let sizeMod = w.level === 3 ? 1.5 : 1;
                    if (w.id === 'orbit') return;
                    if (w.id === 'nova') { bullets.push({x:ox, y:oy, vx:0, vy:6, dmg:dmg, sz:20*sizeMod, c:col, piercing:true}); if(w.level===3) bullets.push({x:ox, y:oy, vx:0, vy:6, dmg:dmg, sz:35, c:col, piercing:true}); }
                    else if (w.id === 'rail') { bullets.push({x:ox, y:oy, vx:0, vy:40, dmg:dmg, sz:5, c:col, laser:true}); if(w.level===3) { bullets.push({x:ox-5, y:oy, vx:-2, vy:40, dmg:dmg/2, sz:3, c:col, laser:true}); bullets.push({x:ox+5, y:oy, vx:2, vy:40, dmg:dmg/2, sz:3, c:col, laser:true}); } }
                    else if (w.id === 'standard') { bullets.push({x:ox, y:oy, vx:0, vy:18, dmg:dmg, sz:4*sizeMod, c:col}); if(w.level>=2) bullets.push({x:ox-10, y:oy+5, vx:0, vy:18, dmg:dmg, sz:3, c:col}); if(w.level===3) bullets.push({x:ox+10, y:oy+5, vx:0, vy:18, dmg:dmg, sz:3, c:col}); }
                    else if (w.id === 'spread') { [-3,0,3].forEach(vx=>bullets.push({x:ox, y:oy, vx, vy:15, dmg:dmg, sz:3*sizeMod, c:col})); if(w.level===3) [-6,6].forEach(vx=>bullets.push({x:ox, y:oy, vx, vy:14, dmg:dmg, sz:3, c:col})); }
                    else if (w.id === 'laser') { bullets.push({x:ox, y:oy, vx:0, vy:30, dmg:dmg, sz:w.level===3?6:2, c:col, laser:true}); }
                    else if (w.id === 'wave') { bullets.push({x:ox, y:oy, vx:0, vy:12, dmg:dmg, sz:5*sizeMod, c:col, wave:true, t:0}); if(w.level===3) bullets.push({x:ox, y:oy, vx:0, vy:12, dmg:dmg, sz:5*sizeMod, c:col, wave:true, t:Math.PI}); }
                    else if (w.id === 'heavy') { bullets.push({x:ox, y:oy, vx:0, vy:8, dmg:dmg, sz:16*sizeMod, c:col}); }
                    else if (w.id === 'rapid') { bullets.push({x:ox+(Math.random()-0.5)*10, y:oy, vx:0, vy:20, dmg:dmg, sz:3, c:col}); if(w.level===3) bullets.push({x:ox+(Math.random()-0.5)*20, y:oy, vx:0, vy:22, dmg:dmg, sz:3, c:col}); }
                    else if (w.id === 'glitch' && enemies.length>0) { let t=enemies[Math.floor(Math.random()*enemies.length)]; if(t){t.hp-=dmg; createParticles(t.x+15,t.y+15,3,col); } if(w.level===3){ let t2=enemies[Math.floor(Math.random()*enemies.length)]; if(t2)t2.hp-=dmg; } }
                });
                let orbitW = p_weapons.find(w => w.id === 'orbit');
                if(orbitW && frameCount % (60 - orbitW.level * 10) === 0) enemies.forEach(e => { if(Math.random()<0.3 * orbitW.level) e.hp -= 20 * orbitW.level; createParticles(e.x+15, e.y+15, 2, "#fff"); });
                playSfx('shoot', 1 + Math.random()*0.2, 0.5);
            }
            draw() {
                ctx.save(); ctx.translate(this.x + this.size/2, this.y + this.size/2);
                if (damageFlash > 0) ctx.translate((Math.random()-0.5)*20, (Math.random()-0.5)*20);
                ctx.shadowBlur = 15; ctx.shadowColor = "#0f0"; ctx.strokeStyle = "#fff"; ctx.lineWidth = 3;
                ctx.strokeRect(-this.size/2, -this.size/2, this.size, this.size); ctx.fillStyle = "#fff"; ctx.fillRect(-4, -4, 8, 8); 
                p_weapons.forEach((w, i) => { ctx.fillStyle = w.level === 3 ? "#FFD700" : "#0f0"; ctx.fillRect(-14 + (i*6), 14, 4, 4); });
                ctx.restore();
            }
        }
        const player = new Player();

        function spawnEnemy() {
            if (boss) return;
            const maxTypeIndex = Math.min(level - 1, 4); 
            const pickIdx = Math.floor(Math.random() * (maxTypeIndex + 1));
            const type = ENEMY_TYPES[pickIdx];
            
            // AGGRESSIVE SPAWN: Spawn Multiple at once based on level
            let burstCount = Math.max(1, Math.floor(level / 1.5));
            for(let i=0; i<burstCount; i++) {
                enemies.push({ 
                    x: Math.random() * (C.w - C.uiWidth - 40), y: -50 - (i*30), 
                    hp: type.hp + (level * 2), 
                    s: type.s, color: type.color, type: type.type, score: type.score,
                    rot: 0, rs: (Math.random()-0.5)*0.2 
                });
            }
        }

        function drawBackground() {
            gridOffset = (gridOffset + 2) % 40;
            ctx.fillStyle = "rgba(0, 20, 0, 0.3)"; ctx.strokeStyle = "rgba(0, 50, 0, 0.5)"; ctx.lineWidth = 1;
            for (let x = 0; x < C.w - C.uiWidth; x += 40) { ctx.beginPath(); ctx.moveTo(x, 0); ctx.lineTo(x, C.h); ctx.stroke(); }
            for (let y = gridOffset; y < C.h; y += 40) { ctx.beginPath(); ctx.moveTo(0, y); ctx.lineTo(C.w - C.uiWidth, y); ctx.stroke(); }
        }

        function loop() {
            if (gameState === 'PLAY') {
                frameCount++;
                if (damageFlash > 0) damageFlash--;
                ctx.fillStyle = damageFlash > 0 ? `rgba(50, 0, 0, 0.5)` : "rgba(0, 0, 0, 0.7)"; ctx.fillRect(0, 0, C.w, C.h);
                drawBackground();

                // FASTER SPAWN RATE
                let spawnRate = Math.max(8, 25 - level * 3); 
                if (frameCount % spawnRate === 0) spawnEnemy();

                if (exp >= nextLevelExp && upgradesInStage < 3) { 
                    exp -= nextLevelExp; 
                    nextLevelExp = Math.floor(nextLevelExp * 1.2); 
                    showUpgradeMenu();
                } else if (exp >= nextLevelExp && upgradesInStage >= 3 && !boss) {
                    exp = nextLevelExp; 
                }

                if (shake > 0) { ctx.save(); ctx.translate((Math.random()-0.5)*shake, (Math.random()-0.5)*shake); shake *= 0.9; }

                player.update(); player.draw();

                drops.forEach((d, i) => {
                    d.y += 2; ctx.save(); ctx.shadowBlur = 10; ctx.shadowColor = d.c; ctx.fillStyle = d.c; ctx.fillRect(d.x-5, d.y-5, 10, 10); ctx.restore();
                    if (Math.abs(d.x - (player.x+12)) < 30 && Math.abs(d.y - (player.y+12)) < 30) {
                        if(d.type === 'exp') { exp += 200; addLog("DATA +200"); playSfx('powerup', 2, 0.3); }
                        else if (d.type === 'heal') { health = Math.min(100, health + 25); addLog("REPAIRED"); playSfx('powerup', 1, 0.5); }
                        else if (d.type === 'bomb') { triggerWipe(false); addLog("AUTO_BOMB"); }
                        drops.splice(i, 1); 
                    }
                    if (d.y > C.h) drops.splice(i, 1);
                });

                bullets.forEach((b, i) => {
                    if (b.wave) { b.t += 0.2; b.x += Math.sin(b.t) * 12; }
                    b.y -= b.vy; b.x += b.vx;
                    ctx.save(); ctx.shadowBlur = 10; ctx.shadowColor = b.c; ctx.fillStyle = b.c; ctx.fillRect(b.x - b.sz/2, b.y, b.sz, b.laser ? 200 : 15); ctx.restore();

                    if (boss && b.x > boss.x && b.x < boss.x+boss.size && b.y > boss.y && b.y < boss.y+boss.size) {
                        boss.hp -= b.dmg; 
                        if (!b.laser && !b.piercing) bullets.splice(i, 1); 
                        createParticles(b.x, b.y, 2, b.c, 0.5); 
                        if (boss.hp <= 0) { 
                            createParticles(boss.x+60, boss.y+60, 50, boss.data.color, 3); 
                            score += 10000; playSfx('explode', 0.2, 1); 
                            if (level === 4) triggerVictory(); // VICTORY AT LEVEL 4
                            else { 
                                boss = null; level++; upgradesInStage = 0; 
                                playMusic('AMBIENT'); 
                                addLog(`STAGE ${level} INITIALIZED`);
                            }
                        }
                    }
                    enemies.forEach((e, ei) => {
                        if (b.x > e.x && b.x < e.x+30 && b.y > e.y && b.y < e.y+30) {
                            e.hp -= b.dmg; createParticles(b.x, b.y, 3, b.c); 
                            if (!b.laser && !b.piercing) bullets.splice(i, 1);
                            if (e.hp <= 0) {
                                createParticles(e.x+15, e.y+15, 12, e.color);
                                drops.push({x: e.x+15, y: e.y+15, type: 'exp', c: '#0f0'});
                                if (Math.random() < 0.1) drops.push({x: e.x+15, y: e.y+15, type: Math.random() < 0.5 ? 'bomb' : 'heal', c: '#ff0'});
                                enemies.splice(ei, 1); score += e.score; playSfx('explode', 1, 0.3);
                            }
                        }
                    });
                    if (b.y < -200) bullets.splice(i, 1);
                });

                enemies.forEach((e, i) => {
                    e.y += e.s; e.rot += e.rs;
                    if (player.x < e.x + 30 && player.x + player.size > e.x && player.y < e.y + 30 && player.y + player.size > e.y) {
                        health -= 20; damageFlash = 20; shake = 30; createParticles(e.x+15, e.y+15, 15, "#f00"); enemies.splice(i, 1); playSfx('hit', 1, 0.8); return;
                    }
                    ctx.save(); ctx.translate(e.x+15, e.y+15); ctx.rotate(e.rot); ctx.shadowBlur = 10; ctx.shadowColor = e.color; ctx.strokeStyle = e.color; ctx.lineWidth = 2;
                    
                    if(e.type === 'grunt') ctx.strokeRect(-15, -15, 30, 30);
                    else if(e.type === 'rusher') { ctx.beginPath(); ctx.moveTo(0, -15); ctx.lineTo(15, 15); ctx.lineTo(-15, 15); ctx.closePath(); ctx.stroke(); }
                    else if(e.type === 'tank') { ctx.strokeRect(-18, -18, 36, 36); ctx.strokeRect(-8, -8, 16, 16); }
                    else if(e.type === 'sniper') { ctx.beginPath(); ctx.moveTo(0,-15); ctx.lineTo(15,0); ctx.lineTo(0,15); ctx.lineTo(-15,0); ctx.closePath(); ctx.stroke(); }
                    else if(e.type === 'swarmer') { ctx.beginPath(); ctx.moveTo(-10,-10); ctx.lineTo(10,10); ctx.moveTo(10,-10); ctx.lineTo(-10,10); ctx.stroke(); }

                    ctx.restore(); if (e.y > C.h) enemies.splice(i, 1); 
                });

                enemyBullets.forEach((eb, i) => {
                    eb.y += eb.vy; eb.x += eb.vx; 
                    ctx.save(); ctx.shadowBlur = 5; ctx.shadowColor = "#f00"; ctx.fillStyle = "#f00"; ctx.fillRect(eb.x-eb.sz/2, eb.y-eb.sz/2, eb.sz, eb.sz); ctx.restore();
                    if (eb.x > player.x && eb.x < player.x+player.size && eb.y > player.y && eb.y < player.y+player.size) {
                        health -= 10; enemyBullets.splice(i, 1); damageFlash = 15; shake = 20; playSfx('hit', 1.5, 0.5);
                    }
                    if (eb.y > C.h || eb.x < 0 || eb.x > C.w) enemyBullets.splice(i, 1);
                });

                particles.forEach((p, i) => {
                    p.x += p.vx; p.y += p.vy; p.life -= p.decay; ctx.fillStyle = p.color; ctx.globalAlpha = p.life; ctx.fillRect(p.x, p.y, p.size, p.size); ctx.globalAlpha = 1.0;
                    if (p.life <= 0) particles.splice(i, 1);
                });

                if (boss) { boss.update(); boss.draw(); }
                if (shake > 0) ctx.restore();

                ctx.fillStyle = "#020202"; ctx.fillRect(C.w-C.uiWidth, 0, C.uiWidth, C.h);
                ctx.strokeStyle = "#111"; ctx.lineWidth = 2; ctx.beginPath(); ctx.moveTo(C.w-C.uiWidth, 0); ctx.lineTo(C.w-C.uiWidth, C.h); ctx.stroke();
                ctx.save(); ctx.globalAlpha = 0.1; ctx.fillStyle = "#0f0"; for(let y=0; y<C.h; y+=10) ctx.fillRect(C.w-C.uiWidth, y, C.uiWidth, 1); ctx.restore();

                ctx.fillStyle = "#0f0"; ctx.font = "24px VT323"; ctx.fillText(`[ SYSTEM_V35 ]`, C.w-C.uiWidth+20, 40);
                
                ctx.font = "20px VT323"; ctx.fillStyle = "#fff";
                ctx.fillText(`SCORE: ${score}`, C.w-C.uiWidth+20, 80); 
                let stageText = `STAGE: ${level}/4 - ${upgradesInStage >= 3 ? 'BOSS' : 'PREP ' + (upgradesInStage+1) + '/3'}`;
                ctx.fillText(stageText, C.w-C.uiWidth+20, 100);
                
                ctx.fillStyle = "#222"; ctx.fillRect(C.w-C.uiWidth+20, 110, 170, 8);
                ctx.fillStyle = "#0f0"; ctx.shadowBlur = 5; ctx.shadowColor = "#0f0"; ctx.fillRect(C.w-C.uiWidth+20, 110, (exp/nextLevelExp)*170, 8); ctx.shadowBlur = 0;

                ctx.fillStyle = health < 30 ? "#f00" : "#fff"; ctx.fillText(`INTEGRITY: ${health}%`, C.w-C.uiWidth+20, 150);
                ctx.fillStyle = "#222"; ctx.fillRect(C.w-C.uiWidth+20, 160, 170, 15);
                ctx.fillStyle = health < 30 ? "#f00" : "#fff"; ctx.fillRect(C.w-C.uiWidth+20, 160, (health/100)*170, 15);

                ctx.fillStyle = "#888"; ctx.fillText("ACTIVE MODULES:", C.w-C.uiWidth+20, 220);
                p_weapons.forEach((w, i) => {
                    let txt = `> ${w.name}`;
                    if (w.level === 3) { ctx.fillStyle = "#FFD700"; txt += " [MAX]"; }
                    else { ctx.fillStyle = w.color; txt += ` [LV ${w.level}]`; }
                    ctx.fillText(txt, C.w-C.uiWidth+20, 245 + (i*25));
                });

                ctx.fillStyle = "#0f0"; ctx.font = "16px VT323";
                logs.forEach((l, i) => ctx.fillText(l, C.w-C.uiWidth+20, 450 + i*20));
            }
            if (health <= 0) { 
                ctx.fillStyle = "red"; ctx.font = "40px VT323"; ctx.fillText("FATAL_ERROR: SYSTEM_HALT", 50, 300);
                setTimeout(() => location.reload(), 2000); return;
            }
            requestAnimationFrame(loop);
        }
        loop();
    }
</script>
</body>
</html>
