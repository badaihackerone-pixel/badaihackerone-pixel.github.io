<!DOCTYPE html>
<html lang="id">
<head>
    <meta charset="UTF-8">
    <title>1-Bit Glitch Protocol | ARSENAL_V24_REFORGED</title>
    <style>
        body { margin: 0; overflow: hidden; background: #020202; display: flex; justify-content: center; align-items: center; height: 100vh; font-family: 'Courier New', monospace; color: #fff; }
        canvas { border: 2px solid #333; background: #000; box-shadow: 0 0 30px rgba(255,0,0,0.1); image-rendering: pixelated; }
        #boot, #upgrade-ui { position: absolute; background: rgba(0,0,0,0.95); width: 800px; height: 600px; display: flex; flex-direction: column; justify-content: center; align-items: center; z-index: 10; border: 4px solid #fff; box-sizing: border-box; }
        #upgrade-ui { display: none; background: rgba(5, 10, 5, 0.98); border-color: #0f0; }
        .option { border: 1px solid #0f0; padding: 20px; margin: 10px; width: 350px; cursor: pointer; transition: 0.2s; background: rgba(0,40,0,0.3); position: relative; overflow: hidden; }
        .option:hover { background: #0f0; color: #000; box-shadow: 0 0 20px #0f0; transform: scale(1.05); }
        .blink { animation: blinker 0.8s linear infinite; font-weight: bold; color: #f00; }
        @keyframes blinker { 50% { opacity: 0; } }
        .scanline { position: absolute; top: 0; left: 0; width: 100%; height: 100%; background: linear-gradient(rgba(18, 16, 16, 0) 50%, rgba(0, 0, 0, 0.25) 50%), linear-gradient(90deg, rgba(255, 0, 0, 0.04), rgba(0, 255, 0, 0.01), rgba(0, 255, 0, 0.04)); background-size: 100% 3px, 3px 100%; pointer-events: none; z-index: 5; }
    </style>
</head>
<body>
    <div class="scanline"></div>
    <div id="boot">
        <h1 style="letter-spacing: 8px; text-shadow: 2px 2px #f00;">[ PROTOCOL_V24 ]</h1>
        <p class="blink">> SYSTEM_BREACH_READY <</p>
        <div style="font-size: 11px; opacity: 0.5; margin-top: 50px; text-align: center;">UPGRADED: UNIQUE_BOSS_PATTERNS<br>ENABLED: ENEMY_VARIETY_STACKING</div>
    </div>

    <div id="upgrade-ui">
        <h2 style="color: #0f0; text-shadow: 0 0 15px #0f0;">>> DATA_EVOLUTION_FOUND <<</h2>
        <div id="options-container"></div>
    </div>

    <canvas id="gameCanvas"></canvas>

<script>
    const boot = document.getElementById('boot');
    const upgradeUI = document.getElementById('upgrade-ui');
    const optionsContainer = document.getElementById('options-container');

    boot.onclick = () => { boot.style.display = 'none'; initGame(); };

    function initGame() {
        const C = { w: 800, h: 600, uiWidth: 220 };
        const canvas = document.getElementById('gameCanvas');
        const ctx = canvas.getContext('2d');
        canvas.width = C.w; canvas.height = C.h;

        const AC = new (window.AudioContext || window.webkitAudioContext)();
        function playSfx(f, type = 'square', d = 0.1, vol = 0.05) {
            try {
                const osc = AC.createOscillator(); const gain = AC.createGain();
                osc.type = type; osc.frequency.setValueAtTime(f, AC.currentTime);
                osc.frequency.exponentialRampToValueAtTime(f > 100 ? 10 : 1, AC.currentTime + d);
                gain.gain.setValueAtTime(vol, AC.currentTime);
                gain.gain.exponentialRampToValueAtTime(0.001, AC.currentTime + d);
                osc.connect(gain); gain.connect(AC.destination);
                osc.start(); osc.stop(AC.currentTime + d);
            } catch(e) {}
        }

        const WEAPON_TYPES = [
            { id: 'standard', name: "CORE_BOLT", desc: "Stable energy stream", dmg: 10, color: "#fff" },
            { id: 'spread', name: "FAN_LOGIC", desc: "Wide area coverage", dmg: 7, color: "#0ff" },
            { id: 'laser', name: "VOID_PIERCER", desc: "Infinite penetration", dmg: 5, color: "#f0f" },
            { id: 'wave', name: "SINE_ERROR", desc: "Erratic movement", dmg: 18, color: "#ff0" },
            { id: 'heavy', name: "NULL_POINTER", desc: "Devastating mass driver", dmg: 60, color: "#f00" },
            { id: 'glitch', name: "BIT_CRUSHER", desc: "Instant target injection", dmg: 35, color: "#0f0" },
            { id: 'rapid', name: "OVERCLOCK", desc: "Maximum fire cycle", dmg: 5, color: "#fff" },
            { id: 'orbit', name: "SENTINEL_NODE", desc: "Defensive orbital", dmg: 10, color: "#fff" }
        ];

        // Definisi Boss yang berbeda tiap level
        const BOSS_DATA = [
            { name: "ROOT_ACCESSOR", title: "The Entry Point", color: "#0ff" },
            { name: "MEMORY_LEAK", title: "The Overflowing Hive", color: "#f0f" },
            { name: "LOGIC_BOMB", title: "The Destructive Sequence", color: "#f00" },
            { name: "KERNEL_PANIC", title: "The Final Error", color: "#fff" }
        ];

        let score = 0, exp = 0, nextLevelExp = 1500, frameCount = 0, health = 100, level = 1, gameState = 'PLAY';
        let shake = 0, damageFlash = 0;
        let bullets = [], enemyBullets = [], enemies = [], particles = [], drops = [], logs = ["> DEBUG_MODE: ON"];
        let boss = null;
        let p_weapons = [WEAPON_TYPES[0]];
        let stars = Array(100).fill().map(() => ({ x: Math.random() * (C.w - C.uiWidth), y: Math.random() * C.h, s: Math.random() * 3 + 1 }));

        const keys = {};
        window.onkeydown = e => { 
            keys[e.key.toLowerCase()] = true; 
            if(e.key === " ") e.preventDefault();
            if(e.key.toLowerCase() === 'q') manualBomb();
        };
        window.onkeyup = e => keys[e.key.toLowerCase()] = false;

        function addLog(msg) { logs.push(`> ${msg}`); if (logs.length > 7) logs.shift(); }

        function triggerWipe(isManual = false) {
            if (isManual && score < 2000) {
                addLog("BOMB_ERROR: INSUFFICIENT_DATA");
                return;
            }
            if (isManual) score -= 2000;
            
            enemies.forEach(e => createParticles(e.x+15, e.y+15, 15, "#fff"));
            enemies = []; enemyBullets = [];
            shake = 40; damageFlash = 15;
            addLog("CRITICAL_WIPE: SUCCESS");
            playSfx(40, 'sawtooth', 0.6, 0.2);
        }

        function manualBomb() { triggerWipe(true); }

        function createParticles(x, y, count = 8, color = "#fff") {
            for(let i=0; i<count; i++) {
                particles.push({
                    x, y, 
                    vx: (Math.random()-0.5)*12, 
                    vy: (Math.random()-0.5)*12, 
                    life: 1.0, 
                    decay: 0.02 + Math.random()*0.04,
                    color,
                    size: Math.random()*4 + 1
                });
            }
        }

        function showUpgradeMenu() {
            gameState = 'UPGRADE';
            upgradeUI.style.display = 'flex';
            optionsContainer.innerHTML = '';
            const shuffled = [...WEAPON_TYPES].sort(() => 0.5 - Math.random()).slice(0, 3);
            shuffled.forEach(w => {
                const div = document.createElement('div');
                div.className = 'option';
                div.innerHTML = `<b style="color:${w.color}">[ ${w.name} ]</b><br><small style="opacity:0.7">${w.desc}</small>`;
                div.onclick = () => {
                    if (p_weapons.length >= 4) p_weapons.shift();
                    p_weapons.push(w);
                    addLog("LOADED: " + w.name);
                    upgradeUI.style.display = 'none';
                    gameState = 'PLAY';
                };
                optionsContainer.appendChild(div);
            });
        }

        class Boss {
            constructor(lvlIdx) {
                this.id = lvlIdx;
                this.data = BOSS_DATA[lvlIdx] || {name: "OVERLOAD", title: "System God", color: "#fff"};
                this.size = 120;
                this.x = (C.w-C.uiWidth)/2 - 60; this.y = -150;
                this.hp = 2000 + (lvlIdx * 3500); 
                this.maxHp = this.hp;
                this.t = 0;
            }
            update() {
                if (this.y < 80) this.y += 1;
                this.t += 0.02;
                
                // Pergerakan unik tiap boss
                if(this.id === 0) this.x += Math.sin(this.t) * 3;
                else if(this.id === 1) { this.x += Math.cos(this.t*1.5) * 5; this.y += Math.sin(this.t*0.5)*1; }
                else { this.x += Math.sin(this.t*2) * 8; }

                // Serangan unik tiap boss
                if (frameCount % 45 === 0) {
                    if(this.id === 0) { // Circle Burst
                        for(let i=0; i<8; i++) {
                            let ang = (Math.PI*2/8)*i;
                            enemyBullets.push({x: this.x+60, y: this.y+60, vx: Math.cos(ang)*4, vy: Math.sin(ang)*4, sz: 8});
                        }
                    } else if (this.id === 1) { // Triple Shot + Random
                        for(let i=-2; i<=2; i++) {
                            enemyBullets.push({x: this.x+60, y: this.y+60, vx: i*1.5, vy: 5, sz: 10});
                        }
                    } else { // Chaos Stream
                        for(let i=0; i<3; i++) {
                            enemyBullets.push({x: this.x+60, y: this.y+60, vx: (Math.random()-0.5)*10, vy: Math.random()*6+2, sz: 6});
                        }
                    }
                    playSfx(200, 'sawtooth', 0.1, 0.02);
                }
            }
            draw() {
                ctx.save();
                ctx.translate(this.x + 60, this.y + 60);
                if(this.id >= 2) ctx.rotate(this.t);
                
                ctx.strokeStyle = this.data.color;
                ctx.lineWidth = 4;
                ctx.strokeRect(-60 + (Math.random()-0.5)*5, -60, this.size, this.size);
                
                // Visual mata berbeda tiap boss
                ctx.fillStyle = "#fff";
                if(this.id === 0) { ctx.fillRect(-40, -20, 20, 20); ctx.fillRect(20, -20, 20, 20); }
                else if(this.id === 1) { ctx.fillRect(-30, -30, 60, 10); ctx.fillRect(-10, -10, 20, 20); }
                else { ctx.beginPath(); ctx.arc(0,0, 30, 0, Math.PI*2); ctx.fill(); }
                
                ctx.restore();

                const barW = 400;
                const barX = (C.w - C.uiWidth) / 2 - barW / 2;
                ctx.fillStyle = "#200";
                ctx.fillRect(barX, 30, barW, 10);
                ctx.fillStyle = this.data.color;
                ctx.fillRect(barX, 30, (this.hp / this.maxHp) * barW, 10);
                ctx.strokeStyle = "#fff";
                ctx.strokeRect(barX, 30, barW, 10);
                ctx.font = "10px monospace";
                ctx.fillText(this.data.name + ": " + this.data.title, barX, 25);
            }
        }

        class Player {
            constructor() { this.x = (C.w-C.uiWidth)/2; this.y = C.h-100; this.size = 24; }
            update() {
                let s = keys['shift'] ? 3.5 : 7;
                if (keys['w'] || keys['arrowup']) this.y -= s;
                if (keys['s'] || keys['arrowdown']) this.y += s;
                if (keys['a'] || keys['arrowleft']) this.x -= s;
                if (keys['d'] || keys['arrowright']) this.x += s;
                this.x = Math.max(0, Math.min(C.w - C.uiWidth - this.size, this.x));
                this.y = Math.max(0, Math.min(C.h - this.size, this.y));
                if (keys[' '] && frameCount % 8 === 0) this.fire();
            }
            fire() {
                p_weapons.forEach((w) => {
                    const ox = this.x + this.size/2, oy = this.y;
                    if (w.id === 'standard' || w.id === 'rapid') bullets.push({x: ox, y: oy, vx: 0, vy: 18, dmg: w.dmg, sz: 4, c: w.color});
                    else if (w.id === 'spread') [-3, 0, 3].forEach(vx => bullets.push({x: ox, y: oy, vx, vy: 15, dmg: w.dmg, sz: 3, c: w.color}));
                    else if (w.id === 'laser') bullets.push({x: ox, y: oy, vx: 0, vy: 30, dmg: w.dmg, sz: 2, c: w.color, laser: true});
                    else if (w.id === 'wave') bullets.push({x: ox, y: oy, vx: 0, vy: 12, dmg: w.dmg, sz: 5, c: w.color, wave: true, t: 0});
                    else if (w.id === 'heavy') bullets.push({x: ox, y: oy, vx: 0, vy: 8, dmg: w.dmg, sz: 16, c: w.color});
                    else if (w.id === 'glitch' && enemies.length > 0) {
                        let t = enemies[0]; t.hp -= w.dmg; createParticles(t.x+15, t.y+15, 3, w.color);
                    }
                });
                playSfx(800, 'square', 0.03, 0.03);
            }
            draw() {
                ctx.save();
                ctx.translate(this.x + this.size/2, this.y + this.size/2);
                if (damageFlash > 0) ctx.translate((Math.random()-0.5)*12, (Math.random()-0.5)*12);
                ctx.strokeStyle = "#fff";
                ctx.lineWidth = 3;
                ctx.strokeRect(-this.size/2, -this.size/2, this.size, this.size);
                ctx.fillStyle = "#fff";
                ctx.fillRect(-2, -2, 4, 4);
                ctx.restore();
            }
        }

        const player = new Player();

        function spawnEnemy() {
            if (boss) return;
            // Mekanisme Keroco: Jenis baru muncul tiap level tanpa menghapus yang lama
            const types = [];
            types.push({type: 'grunt', hp: 15, s: 3, color: '#fff'}); // Level 1+
            if(level >= 3) types.push({type: 'rusher', hp: 10, s: 6, color: '#f0f'}); // Level 3+
            if(level >= 5) types.push({type: 'tank', hp: 100, s: 1.5, color: '#0ff'}); // Level 5+
            
            const pick = types[Math.floor(Math.random() * types.length)];
            enemies.push({ 
                x: Math.random() * (C.w - C.uiWidth - 40), 
                y: -50, 
                hp: pick.hp + (level * 5), 
                s: pick.s, 
                color: pick.color,
                type: pick.type,
                rot: 0, rs: (Math.random()-0.5)*0.2 
            });
        }

        function loop() {
            if (gameState === 'PLAY') {
                frameCount++;
                if (damageFlash > 0) damageFlash--;

                ctx.fillStyle = damageFlash > 0 ? `rgba(255, 0, 0, ${damageFlash/20})` : "#000";
                ctx.fillRect(0, 0, C.w, C.h);

                stars.forEach(s => { s.y += s.s; if (s.y > C.h) s.y = -10; ctx.fillStyle = "#222"; ctx.fillRect(s.x, s.y, 2, 2); });

                if (frameCount % 40 === 0) spawnEnemy();

                if (exp >= nextLevelExp) {
                    exp -= nextLevelExp; nextLevelExp += 2000;
                    level++;
                    addLog("EVOLUTION_READY");
                    showUpgradeMenu();
                    if (level % 3 === 0) boss = new Boss(Math.floor(level/3)-1);
                }

                if (shake > 0) { ctx.save(); ctx.translate((Math.random()-0.5)*shake, (Math.random()-0.5)*shake); shake *= 0.9; }

                player.update(); player.draw();

                // Drops
                drops.forEach((d, i) => {
                    d.y += 2;
                    ctx.fillStyle = d.c;
                    ctx.fillRect(d.x-5, d.y-5, 10, 10);
                    if (Math.abs(d.x - (player.x+12)) < 30 && Math.abs(d.y - (player.y+12)) < 30) {
                        if(d.type === 'exp') { exp += 200; addLog("DATA_ACQUIRED +200"); }
                        else if (d.type === 'heal') { health = Math.min(100, health + 25); addLog("INTEGRITY_REPAIRED"); }
                        else if (d.type === 'bomb') { triggerWipe(false); addLog("ITEM_BOMB_DETONATED"); }
                        drops.splice(i, 1); playSfx(1000, 'sine', 0.1, 0.05);
                    }
                    if (d.y > C.h) drops.splice(i, 1);
                });

                // Bullets Collision
                bullets.forEach((b, i) => {
                    if (b.wave) { b.t += 0.2; b.x += Math.sin(b.t) * 12; }
                    b.y -= b.vy; b.x += b.vx;
                    ctx.fillStyle = b.c;
                    ctx.fillRect(b.x - b.sz/2, b.y, b.sz, b.laser ? 200 : 15);
                    
                    if (boss && b.x > boss.x && b.x < boss.x+boss.size && b.y > boss.y && b.y < boss.y+boss.size) {
                        boss.hp -= b.dmg;
                        if (!b.laser) bullets.splice(i, 1);
                        if (boss.hp <= 0) { 
                            createParticles(boss.x+60, boss.y+60, 40, boss.data.color);
                            boss = null; score += 10000; addLog("MAJOR_TARGET_NEUTRALIZED"); 
                            playSfx(100, 'sawtooth', 0.5, 0.2);
                        }
                    }

                    enemies.forEach((e, ei) => {
                        if (b.x > e.x && b.x < e.x+30 && b.y > e.y && b.y < e.y+30) {
                            e.hp -= b.dmg;
                            createParticles(b.x, b.y, 3, b.c);
                            if (!b.laser) bullets.splice(i, 1);
                            if (e.hp <= 0) {
                                createParticles(e.x+15, e.y+15, 10, e.color);
                                drops.push({x: e.x+15, y: e.y+15, type: 'exp', c: '#0f0'});
                                if (Math.random() < 0.1) drops.push({x: e.x+15, y: e.y+15, type: Math.random() < 0.5 ? 'bomb' : 'heal', c: '#ff0'});
                                enemies.splice(ei, 1); score += 100;
                            }
                        }
                    });
                    if (b.y < -200) bullets.splice(i, 1);
                });

                // Enemies Logic
                enemies.forEach((e, i) => {
                    e.y += e.s;
                    e.rot += e.rs;
                    if (player.x < e.x + 30 && player.x + player.size > e.x && player.y < e.y + 30 && player.y + player.size > e.y) {
                        health -= 20; damageFlash = 20; shake = 30;
                        createParticles(e.x+15, e.y+15, 15, "#f00");
                        enemies.splice(i, 1);
                        playSfx(50, 'sawtooth', 0.3, 0.15);
                        return;
                    }
                    ctx.save();
                    ctx.translate(e.x+15, e.y+15);
                    ctx.rotate(e.rot);
                    ctx.strokeStyle = e.color;
                    ctx.lineWidth = 2;
                    // Visual keroco berbeda
                    if(e.type === 'grunt') ctx.strokeRect(-15, -15, 30, 30);
                    else if(e.type === 'rusher') { ctx.beginPath(); ctx.moveTo(0, -15); ctx.lineTo(15, 15); ctx.lineTo(-15, 15); ctx.closePath(); ctx.stroke(); }
                    else { ctx.strokeRect(-15, -15, 30, 30); ctx.strokeRect(-8, -8, 16, 16); }
                    ctx.restore();
                    if (e.y > C.h) enemies.splice(i, 1); 
                });

                // Enemy Bullets
                enemyBullets.forEach((eb, i) => {
                    eb.y += eb.vy; eb.x += eb.vx;
                    ctx.fillStyle = "#f00";
                    ctx.fillRect(eb.x-eb.sz/2, eb.y-eb.sz/2, eb.sz, eb.sz);
                    if (eb.x > player.x && eb.x < player.x+player.size && eb.y > player.y && eb.y < player.y+player.size) {
                        health -= 10; enemyBullets.splice(i, 1);
                        damageFlash = 15; shake = 20;
                        playSfx(100, 'square', 0.1, 0.1);
                    }
                    if (eb.y > C.h || eb.x < 0 || eb.x > C.w) enemyBullets.splice(i, 1);
                });

                particles.forEach((p, i) => {
                    p.x += p.vx; p.y += p.vy; p.life -= p.decay;
                    ctx.fillStyle = p.color;
                    ctx.fillRect(p.x, p.y, p.size, p.size);
                    if (p.life <= 0) particles.splice(i, 1);
                });

                if (boss) { boss.update(); boss.draw(); }
                if (shake > 0) ctx.restore();

                // UI Panel
                ctx.fillStyle = "#080808"; ctx.fillRect(C.w-C.uiWidth, 0, C.uiWidth, C.h);
                ctx.fillStyle = "#0f0"; ctx.font = "12px monospace";
                ctx.fillText(`[ PROTOCOL_V24 ]`, C.w-C.uiWidth+20, 40);
                ctx.fillStyle = "#fff";
                ctx.fillText(`SCORE: ${score}`, C.w-C.uiWidth+20, 70);
                ctx.fillText(`LVL: ${level}`, C.w-C.uiWidth+20, 90);
                ctx.fillStyle = "#222"; ctx.fillRect(C.w-C.uiWidth+20, 110, 170, 10);
                ctx.fillStyle = "#0f0"; ctx.fillRect(C.w-C.uiWidth+20, 110, (exp/nextLevelExp)*170, 10);
                ctx.fillStyle = health < 30 ? "#f00" : "#fff";
                ctx.fillText(`INTEGRITY: ${health}%`, C.w-C.uiWidth+20, 150);
                ctx.fillRect(C.w-C.uiWidth+20, 160, (health/100)*170, 15);
                ctx.fillStyle = score >= 2000 ? "#0ff" : "#444";
                ctx.fillText(`BOMB_SYSTEM: ${score >= 2000 ? 'READY' : 'CHARGING'}`, C.w-C.uiWidth+20, 210);
                ctx.fillText(`[Press 'Q' to WIPE]`, C.w-C.uiWidth+20, 230);
                ctx.fillStyle = "#444";
                logs.forEach((l, i) => ctx.fillText(l, C.w-C.uiWidth+20, 450 + i*20));
            }
            if (health <= 0) { 
                ctx.fillStyle = "red"; ctx.font = "30px monospace"; ctx.fillText("KERNEL_CRITICAL_FAILURE", 50, 300);
                setTimeout(() => location.reload(), 1500); return;
            }
            requestAnimationFrame(loop);
        }
        loop();
    }
</script>
</body>
</html>
