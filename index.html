<!DOCTYPE html>
<html lang="id">
<head>
    <meta charset="UTF-8">
    <title>1-Bit Glitch Protocol | BALANCED_V6</title>
    <style>
        body { margin: 0; overflow: hidden; background: #000; display: flex; justify-content: center; align-items: center; height: 100vh; font-family: 'Courier New', monospace; color: #fff; }
        canvas { border: 4px solid #fff; background: #050505; image-rendering: pixelated; box-shadow: 0 0 60px rgba(255,255,255,0.1); }
        #boot { position: absolute; background: black; width: 800px; height: 600px; display: flex; flex-direction: column; justify-content: center; align-items: center; z-index: 10; cursor: pointer; text-align: center; border: 4px solid #fff; }
        .blink { animation: blinker 1.5s linear infinite; }
        @keyframes blinker { 50% { opacity: 0; } }
        #overlay { pointer-events: none; position: absolute; width: 800px; height: 600px; background: linear-gradient(rgba(18, 16, 16, 0) 50%, rgba(0, 0, 0, 0.1) 50%), linear-gradient(90deg, rgba(255, 0, 0, 0.03), rgba(0, 255, 0, 0.01), rgba(0, 0, 255, 0.03)); z-index: 5; background-size: 100% 3px, 3px 100%; }
    </style>
</head>
<body>
    <div id="boot">
        <h1>[ PROTOCOL_BALANCED.V6 ]</h1>
        <p class="blink">> INITIALIZE RESTRICTED_KERNEL <</p>
        <div style="font-size: 11px; margin-top: 20px; text-align: left; opacity: 0.7; border-top: 1px solid #444; padding-top: 10px;">
            SISTEM TERBATAS: Capai Level Baru untuk Unlock Senjata.<br>
            HATI-HATI: Senjata memiliki indikator HEAT (Panas).<br><br>
            [SPACE] FIRE | [1-4] SWITCH | [X] NUKE
        </div>
    </div>
    <div id="overlay"></div>
    <canvas id="gameCanvas"></canvas>

<script>
    const boot = document.getElementById('boot');
    boot.onclick = () => { boot.style.display = 'none'; initGame(); };

    function initGame() {
        const C = { bg: '#050505', fg: '#ffffff', w: 800, h: 600, uiWidth: 220 };
        const canvas = document.getElementById('gameCanvas');
        const ctx = canvas.getContext('2d');
        canvas.width = C.w; canvas.height = C.h;

        const AC = new (window.AudioContext || window.webkitAudioContext)();
        function playSfx(f, type = 'square', d = 0.1, vol = 0.05) {
            try {
                const osc = AC.createOscillator(); const gain = AC.createGain();
                osc.type = type; osc.frequency.setValueAtTime(f, AC.currentTime);
                osc.frequency.exponentialRampToValueAtTime(10, AC.currentTime + d);
                gain.gain.setValueAtTime(vol, AC.currentTime);
                gain.gain.exponentialRampToValueAtTime(0.01, AC.currentTime + d);
                osc.connect(gain); gain.connect(AC.destination);
                osc.start(); osc.stop(AC.currentTime + d);
            } catch(e) {}
        }

        const keys = {};
        let shakeTime = 0, score = 0, frameCount = 0, health = 100, level = 1;
        let heat = 0, overheating = false, combo = 0, comboTimer = 0, nukeAvailable = false;
        let weaponMode = 1;
        let logs = ["> KERNEL_LIMITED_LOADED", "> UNLOCK_REQ: LEVEL_UP", "> MONITOR_HEAT_LEVELS"];
        let bullets = [], enemies = [], particles = [], bg = [];

        window.onkeydown = e => { 
            keys[e.key] = true; 
            if(["1","2","3","4"].includes(e.key)) {
                let requested = parseInt(e.key);
                if (level >= requested) {
                    weaponMode = requested; 
                    playSfx(600, 'sine', 0.05);
                    addLog("MODE_SWITCH: WPN_" + requested);
                } else {
                    addLog("ERR: LEVEL_" + requested + "_REQUIRED");
                    playSfx(100, 'sawtooth', 0.2);
                }
            }
            if(e.key.toLowerCase() === "x" && nukeAvailable) triggerNuke();
            if(e.key === " ") e.preventDefault();
        };
        window.onkeyup = e => keys[e.key] = false;

        function addLog(msg) {
            logs.push(`> ${msg}`); if (logs.length > 15) logs.shift();
        }

        function triggerNuke() {
            nukeAvailable = false; shakeTime = 50;
            playSfx(40, 'sawtooth', 1.2, 0.2);
            enemies.forEach(e => { for(let i=0; i<8; i++) particles.push(new Particle(e.x, e.y)); });
            score += enemies.length * 25; enemies = [];
            addLog("SECTOR_PURGED");
        }

        class Player {
            constructor() { this.size = 16; this.x = (C.w - C.uiWidth)/2; this.y = C.h - 80; this.lastShot = 0; }
            update() {
                let s = overheating ? 3.5 : 5.5; // Slowed when overheating
                if (keys['w'] || keys['ArrowUp']) this.y -= s;
                if (keys['s'] || keys['ArrowDown']) this.y += s;
                if (keys['a'] || keys['ArrowLeft']) this.x -= s;
                if (keys['d'] || keys['ArrowRight']) this.x += s;
                this.x = Math.max(0, Math.min(C.w - C.uiWidth - this.size, this.x));
                this.y = Math.max(0, Math.min(C.h - this.size, this.y));

                if (heat > 0) heat -= overheating ? 0.3 : 0.6;
                if (heat <= 0) { heat = 0; overheating = false; }

                if (keys[' '] && !overheating && Date.now() - this.lastShot > 150) {
                    this.fire(); this.lastShot = Date.now();
                }
            }
            fire() {
                let bX = this.x + this.size/2;
                let hInc = 5;
                if (weaponMode === 1) { // Single
                    bullets.push(new Bullet(bX, this.y, 0, 1));
                    hInc = 4;
                } else if (weaponMode === 2) { // Triple
                    bullets.push(new Bullet(bX, this.y, -1.5, 1));
                    bullets.push(new Bullet(bX, this.y, 0, 1));
                    bullets.push(new Bullet(bX, this.y, 1.5, 1));
                    hInc = 10;
                } else if (weaponMode === 3) { // Pierce
                    bullets.push(new Bullet(bX, this.y, 0, 2));
                    hInc = 25;
                } else if (weaponMode === 4) { // Wave
                    for(let i=-2; i<=2; i++) bullets.push(new Bullet(bX, this.y, i*2, 3));
                    hInc = 20;
                }
                
                heat += hInc;
                if (heat >= 100) { heat = 100; overheating = true; addLog("SYS_OVERHEAT_ERR"); playSfx(150, 'sawtooth', 0.4); }
                playSfx(400 + weaponMode*50, 'square', 0.05, 0.03);
            }
            draw() {
                ctx.fillStyle = overheating ? (frameCount % 4 < 2 ? "#f00" : "#fff") : "#fff";
                ctx.fillRect(this.x, this.y, this.size, this.size);
                ctx.strokeRect(this.x-2, this.y-2, this.size+4, this.size+4);
            }
        }

        class Enemy {
            constructor(type) {
                this.type = type;
                this.size = type === 'tank' ? 24 : 14;
                this.hp = type === 'tank' ? 4 : 1;
                this.x = Math.random() * (C.w - C.uiWidth - this.size);
                this.y = -30;
                this.speed = (type === 'fast' ? 4 : 2) + (level * 0.2);
            }
            update() {
                this.y += this.speed;
                if (this.type === 'fast') this.x += Math.sin(frameCount * 0.1) * 2;
            }
            draw() {
                ctx.strokeRect(this.x, this.y, this.size, this.size);
                if(this.hp > 1) ctx.fillRect(this.x+6, this.y+6, this.size-12, this.size-12);
            }
        }

        class Bullet {
            constructor(x, y, vx, mode) {
                this.x = x; this.y = y; this.vx = vx; this.mode = mode;
                this.speed = mode === 3 ? 7 : 12;
                this.pierce = (mode === 2);
            }
            update() { this.y -= this.speed; this.x += this.vx; }
            draw() { ctx.fillRect(this.x-1, this.y, this.mode === 2 ? 4 : 2, 12); }
        }

        class Particle {
            constructor(x, y) {
                this.x = x; this.y = y; this.vx = (Math.random()-0.5)*10; this.vy = (Math.random()-0.5)*10; this.life = 1;
            }
            update() { this.x += this.vx; this.y += this.vy; this.life -= 0.05; }
            draw() { ctx.globalAlpha = this.life; ctx.fillRect(this.x, this.y, 2, 2); ctx.globalAlpha = 1; }
        }

        const player = new Player();
        for(let i=0; i<30; i++) bg.push({x: Math.random()*(C.w-C.uiWidth), y: Math.random()*C.h, s: Math.random()*1.5});

        function loop() {
            frameCount++;
            if (comboTimer > 0) comboTimer--; else combo = 0;

            ctx.save();
            if (shakeTime > 0) { ctx.translate((Math.random()-0.5)*shakeTime, (Math.random()-0.5)*shakeTime); shakeTime--; }
            
            ctx.fillStyle = C.bg; ctx.fillRect(0,0,C.w,C.h);
            ctx.fillStyle = C.fg;
            bg.forEach(p => { p.y += (p.s + 1); if(p.y > C.h) p.y = 0; ctx.fillRect(p.x, p.y, p.s, p.s); });

            if (frameCount % Math.max(15, 40 - level*2) === 0) {
                let r = Math.random();
                enemies.push(new Enemy(r > 0.85 ? 'tank' : (r > 0.7 ? 'fast' : 'norm')));
            }

            player.update(); player.draw();

            bullets.forEach((b, bi) => {
                b.update(); b.draw();
                enemies.forEach((e, ei) => {
                    if (b.x > e.x && b.x < e.x + e.size && b.y > e.y && b.y < e.y + e.size) {
                        e.hp--; if(!b.pierce) bullets.splice(bi, 1);
                        if (e.hp <= 0) {
                            enemies.splice(ei, 1); score += 100; combo++; comboTimer = 150;
                            for(let i=0; i<4; i++) particles.push(new Particle(e.x, e.y));
                            playSfx(200, 'square', 0.05);
                        }
                    }
                });
                if (b.y < -20) bullets.splice(bi, 1);
            });

            enemies.forEach((e, ei) => {
                e.update(); e.draw();
                if (e.x < player.x + player.size && e.x + e.size > player.x && e.y < player.y + player.size && e.y + e.size > player.y) {
                    enemies.splice(ei, 1); health -= 20; shakeTime = 30;
                    playSfx(60, 'sawtooth', 0.2);
                    addLog("SYS_DAMAGE_DETECTED");
                    if (health <= 0) { alert("FAIL_STATE. Score: " + score); location.reload(); }
                }
                if (e.y > C.h) { enemies.splice(ei, 1); if(score > 0) score -= 10; } // Penalty musuh lolos
            });

            particles.forEach((p, pi) => { p.update(); p.draw(); if(p.life <= 0) particles.splice(pi, 1); });
            ctx.restore();

            // UI
            ctx.fillStyle = "#000"; ctx.fillRect(C.w - C.uiWidth, 0, C.uiWidth, C.h);
            ctx.strokeStyle = "#fff"; ctx.strokeRect(C.w - C.uiWidth + 10, 10, C.uiWidth - 20, C.h - 20);
            
            ctx.fillStyle = "#fff"; ctx.font = "10px monospace";
            logs.forEach((l, i) => ctx.fillText(l, C.w - C.uiWidth + 20, 40 + i*18));

            // Stats
            ctx.font = "bold 13px monospace";
            ctx.fillText(`INTEGRITY: ${health}%`, 20, 40);
            ctx.fillText(`SCORE: ${score}`, 20, 60);
            ctx.fillText(`LVL: ${level}`, 20, 80);
            
            // Heat Meter
            ctx.fillText("WPN_HEAT", 20, 110);
            ctx.strokeRect(20, 115, 100, 10);
            ctx.fillRect(20, 115, heat, 10);
            if (overheating) ctx.fillText("!! OVERHEAT !!", 20, 140);

            // Weapon Unlocks
            ctx.font = "10px monospace";
            for(let i=1; i<=4; i++) {
                ctx.globalAlpha = level >= i ? 1 : 0.3;
                ctx.fillText(`[${i}] ${["SINGLE","TRIPLE","PIERCE","WAVE"][i-1]}`, 20, 170 + i*15);
            }
            ctx.globalAlpha = 1;
            
            if (nukeAvailable) ctx.fillText("[X] NUKE_READY", 20, 260);

            // Leveling Up
            if (score >= level * 3000) {
                level++; nukeAvailable = true;
                addLog("SYSTEM_EVOLVED: LVL " + level);
                playSfx(800, 'sine', 0.5);
            }

            requestAnimationFrame(loop);
        }
        loop();
    }
</script>
</body>
</html>
